# =========================
# 0) Paquetes y semilla
# =========================

library(ABM)
set.seed(1)

# =========================
# 1) Parámetros del modelo CON CAMBIOS
# =========================

N      <- 5000
Tmax   <- 36
delay_prob_base <- 0.15 # CAMBIO: Reducida de 0.30 a 0.15 (mayor puntualidad)
lambda_cred     <- 0.50 # CAMBIO: Aumentada de 0.30 a 0.50 (mayor sensibilidad a retrasos)

# ----- Diseño del programa de transferencias ----- 
base_transfer_per_child <- 700  # CAMBIO: Aumentada de 500 a 700 (mayor monto por hijo)
max_children_paid       <- 2    
poverty_line            <- 4500 

# Parámetros socioeconómicos adicionales
beta_age    <- 0.08      
beta_school <- 0.12      
cost_school <- 150       # CAMBIO: Aumentada de 100 a 150 (mayor costo escolar)
urban_penalty <- 100     # CAMBIO: Aumentada de 50 a 100 (mayor penalización rural)

# =====================================
# 2) Crear simulación y estado inicial
# =====================================

sim <- Simulation$new(N)

for (i in 1:N) {                           
  theta  <- rnorm(1, mean = 300, sd = 80)  
  cred0  <- 1 - delay_prob_base            # Credibilidad inicial ahora 0.85 (vs 0.70 antes)
  
  state0 <- sample(c("E", "ET", "T"), 1, prob = c(0.4, 0.3, 0.3)) 
  
  # Características del hogar
  n_hijos  <- sample(0:3, 1, prob = c(0.25, 0.40, 0.25, 0.10)) 
  Y_hogar  <- rlnorm(1, meanlog = log(4000), sdlog = 0.5)      
  elegible <- (Y_hogar < poverty_line)                         
  
  # Características individuales/ambientales
  edad   <- sample(10:17, 1)                                    
  grado  <- max(1, edad - 6)                                    
  sexo   <- sample(c("M", "F"), 1, prob = c(0.5, 0.5))          
  zona   <- sample(c("urbana", "rural"), 1, prob = c(0.7, 0.3)) 
  if (zona == "rural") theta <- theta + urban_penalty           # Aplica penalización mayor
  
  sim$setState(i, list(
    state0,
    theta     = theta,
    cred      = cred0,
    n_hijos   = n_hijos,
    Y_hogar   = Y_hogar,
    elegible  = elegible,
    edad      = edad,        
    grado     = grado,       
    sexo      = sexo,        
    zona      = zona         
  ))
}

# ======================================
# 3) Loggers (contadores automáticos)
# ======================================

sim$addLogger(newCounter("E", "E"))   
sim$addLogger(newCounter("ET", "ET")) 
sim$addLogger(newCounter("T", "T"))   

# =========================================================
# 4) Handler mensual (la dinámica)
# =========================================================
tick_handler <- function(time, sim, agent) {  
  for (i in 1:N) {                            
    ai <- getAgent(sim, i)                    
    st <- getState(ai)                        
    
    # ----- Cálculo del beneficio -----
    hijos_cubiertos <- min(st$n_hijos, max_children_paid) 
    transfer_eff    <- if (st$elegible) base_transfer_per_child * hijos_cubiertos else 0  
    
    # ----- Cálculo del salario potencial del niñx -----
    w_child <- exp(log(100) + beta_age * st$edad + beta_school * st$grado + rnorm(1, 0, 0.2))  
    
    # ----- Utilidades de las tres opciones -----
    U_E  <- (transfer_eff * st$cred) - cost_school   -   st$theta
    U_ET <- (transfer_eff/2) + (w_child * 0.5) - (cost_school/2)  - (0.5*st$theta)  
    U_T  <- w_child
    
    # ----- Decisión del hogar -----
    utilities <- c(E = U_E, ET = U_ET, T = U_T)  
    new_state <- names(which.max(utilities))     
    
    # ----- Ver si el pago llegó a tiempo -----
    paid_on_time <- (new_state %in% c("E", "ET")) && (runif(1) > delay_prob_base) 
    
    # ----- Actualizar credibilidad (EMA) -----
    cred_new <- (1 - lambda_cred) * st$cred + lambda_cred * as.numeric(paid_on_time)
    
    # ----- Guardar nuevo estado y atributos -----
    setState(ai, list(
      new_state,
      theta     = st$theta,
      cred      = cred_new,
      n_hijos   = st$n_hijos,
      Y_hogar   = st$Y_hogar,
      elegible  = st$elegible,
      edad      = st$edad,
      grado     = st$grado,
      sexo      = st$sexo,
      zona      = st$zona
    ))
  }
  
  if (time < Tmax) schedule(agent, newEvent(time + 1, tick_handler))  
}

# ==============================
# 5) Ejecutar la simulación
# ==============================

schedule(sim$get, newEvent(0, tick_handler)) 
res <- sim$run(0:Tmax)                       
res$attend <- (res$E + res$ET) / N           

res

# ==============================
# 6) Gráfico
# ==============================
library(ggplot2)

p <- ggplot(res, aes(x = times, y = attend)) +
  geom_area(fill = "yellow2", alpha = 0.12) +
  geom_line(size = 1.4, color = "orange", lineend = "round") +
  coord_cartesian(ylim = c(0, 1)) +
  labs(title = "CCT CON CAMBIOS: Mayor puntualidad, sensibilidad, montos y costos",
       x = "Mes", y = "% hogares que asisten") +
  theme_minimal(base_size = 14)

p


##############################################################

# ODD+D
# 1) OVERVIEW (Visión general)
# 
# 1.1 Propósito. ¿Qué pregunta responde el modelo? (¿Cómo afectan monto y puntualidad la asistencia escolar)
#     En este caso los cambios realizados (Mayor puntualidad de 0.30 a 0.15 y mayor monto de $500 a $700)
#     generó un incremento en la asistencia escolar.
# 
# 1.2 Entidades Estados y Escalas
#   1.2.1 Entidad: ¿agente?  Son las familias.
#   1.2.2 Estado principal E (Estudi) y ET (Estudian y trabajan). Si sólo "T" ==> abandono escolar
#   1.2.3 Atributos (theta)  Se mantuvo igual
#   1.2.4 Escalas el tiempo son 36 meses
#   
# 1.3 Proceso y programación
#   1.3.1 Cada tick(mes)
#   1.3.2 Implementación
#   
# 2) DESIGN CONCEPTS
# 
#   Emergencia que surge es la estabilización en la asistencia alrededor del 13%
#     Adaptación
#     Objetivos
#     Aprendizaje/Memoria:
#     Sensing (percepción)  
